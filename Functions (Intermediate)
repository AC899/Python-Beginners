# Positional arguments: when you call arguments by their position in a function

def house(blue_door,red_door):
    print(blue_door,red_door)
house("blue door","red door")


# Keyword arguments =
def house(blue_door,red_door):            # blue door / red door order in the function
    print(red_door, blue_door)
house(red_door = "red", blue_door = "blue")      # the arguments are in reverse order to the above funciton call


# Default arguments
def house(blue_door = "blue", red_door = "red"):     # assigning default values to the parameters
    print(blue_door, red_door)
house()                                           # can call the function without any arguments



#Function call to add argument straight into a dictionary 

tables = {
  1: ['Jiho', False],
  2: [],
  3: [],
  4: [],
  5: [],
  6: [],
  7: [],
}
print(tables)

#
def assign_table(table_number,name,vip_status = False):   #we are adding table_number as key and name,vip_status as the value
    tables[table_number] = [name,vip_status]   #dictionaryname[functionargumentUSEDFORKEY] = [INSERT VALUE, INSERT VALUE]


assign_table(6,"Yoni",False)    #positional argument i.e. working through the function arguments in order table number / name / vip_status
assign_table(4,"Karla")          #positional argument 2 we can set VIP status to false by default (see function argument above) we don't need to change or input in the future

assign_table(name="Martha", table_number=3, vip_status=True)    #keyword argument

print(tables)





# combining the * unpacking operator to cut sentences off at a particular index
tables = {
  1: {
    'name': 'Jiho',
    'vip_status': False,
    'order': 'Orange Juice, Apple Juice'
  },
  2: {},
  3: {},
  4: {},
  5: {},
  6: {},
  7: {},
}
print(tables)

def assign_table(table_number, name, vip_status=False):
  tables[table_number]['name'] = name
  tables[table_number]['vip_status'] = vip_status
  tables[table_number]['order'] = ''     #nested keys

# Write your code below:

def assign_and_print_order(table_number, *order_items):
  tables[table_number]['order'] = order_items
  for i in order_items:
    print(i)


assign_table(2, "Arwa", True)

assign_and_print_order(2, 'Steak', 'Seabass', 'Wine Bottle')
print(tables)










#Unpacking operator in a function argument = *
def print_order(*order_items):        # * allows us to send multiple arguments to the function
    print(order_items)

#print_order(1+2+3,3, "Jmes")        #the unpacking operator returns a tuple (not a list) - unchangeable
print_order("Orange Juice", "Apple Juice", "Scrambled Eggs", "Pancakes")




# args = NON KEYWORD arguments - these are strings in the example below 
# building a print statement for everything entered into the function
def shout_strings(*args):        # use the unpacking operator in the function argument call
    for i in args:               # looping through args
        print(i.lower())           # this is to print in lower case i.e. .lower(). To print normally we take away the paranthesis
shout_strings('Working on', 'learning', 'argument unpacking!')





# combining the * unpacking operator to cut sentences off at a particular index
def truncate_sentences(length, *sentences):       # accepting two parameters: number for length and multiple args for sentences
    for sentence in sentences:                      #looping through the args
        print(sentence[:length])                   #printing looped tuple created by args - slicing with the length argument

truncate_sentences(4, "ASasss", "ASas")




# **kwargs - allows us to define functions within unlimited keyword arguments
#we use kwargs for functions when we dont understand fully whats going on or when we have a function where there is a potential to add a bunch of stuff at a alter point

def my_func(*args, **kwargs):                    #**kwargs allow us to pass through the values of keys / *args are arguments that are not keyword arguments
    print("Hello world", args, kwargs)

my_func("abc", "abc", key =123)



#Example of how KWAGS works in django - the below gives us an error

def my_django_view(request):
    print(request)
my_django_view("request", id = 'some_id')     #we will get an error saying unexpected keyword argument ID

#KWARGS in the function fixes the error

def my_django_view(request, **kwargs): #added KWARGS as a function agrument 
    print(kwargs)                         #kwargs is printed without the ** 

my_django_view("request", id='some_id')     #KWARGS above allowed us to accept the ID parameter as before it was only looking for a request 


# **kwargs - allows us to define functions within unlimited keyword arguments.
# Note: you don't have to call it kwargs

def arbitrary_keyword_args(**kwargs):
    print(kwargs)
    print(kwargs.get('anything_goes'))            #we are retrieivng the value of the key anything_goes and printing it. We have **kwargs above so this allows us to insert the dictionary value below and replicate in a print statement with .get.

arbitrary_keyword_args(name = 1, name2 = 2, anything_goes = 101)





# use args for any number of positional arguments and kwargs to print dictionary / value pairs 
def accept(*args, **ultimate):
    print(ultimate,args)

accept(1,2, num=10, mo = 5, )



# multiply and subtract using ARGS 
def multiply(*nums):
    result = 1
    for num in nums:
        result = num * result
        print(result)

multiply(2,11,10)

def subtract(*nums):
    total = 1
    for i in nums:
        total = i - total
        print(total)

subtract(2,11,5,5)




#using iteration with kwargs
def print_data(**data):                          #allows us to take values / key data that can be specified later on
    for loop in data.values():               #the.values(): part can be switched to .keys() to change what to print 
        print(loop)

print_data(a='arg1', b=True, c=100)             #





#using iteration with kwargs
def print_data(postional_arg, **data):          #adding a positional argument that doesn't have the key / value structure to our function
    print(postional_arg)                     #  without this print statement it won't print the positional below 
    for loop in data.values():               #
        print(loop)

print_data("position 1", a='arg1', b=True, c=100)             #






#Lambda functions: functions in one line that use the word lambda

add_three = lambda my_input: my_input + 3
#add_three is not a variable here as we have lambda (telling us it's a one line function)
#function name < lambda > parameter: parameter w/method
print(add_three(3))

add_five = lambda myinput: myinput + 5
print(add_five(3))


#typical function to a lambda one liner
def add_bang(sentence):
  print(sentence + '!')

add_bang = lambda string: print(string + "!")
add_bang("string")



Hhigher order functions > accept a function as an arugment and return a value that is linked to another function

def total_bill(func, value):  #func means we are taking a function as a parameter for this higher order function 
  total = func(value)    #func means
  return total


def add_tax(total):
    tax = total * 0.06
    new_total = total + tax
    return new_total


total_bill(add_tax, 100)     #the higher order fnction takes in func, value so: higher order function > function we are calling as a parameter, parameter for input (in this case a number




#higher function calling on lower functions for upper / lowercase letters

def higher(func,string):          #the higher function takes in a function and a string as a parameter
    string = func(string)         #tells it we are running the function(s) below over the string 
    return string                

def lower(string):             #the higher function
    return string.lower()

def upper(string):             #the highercase function 
    return string.upper()

print(higher(lower, "hello"))      #higher function name >function we are calling on > additonal parameters in the higher function 




#calling functions as arguments 


def total_bill(func, value):
  total = func(value)
  return total


def add_tax(total):
    tax = total * 0.06
    new_total = total + tax
    return new_total


def add_tip(total):
    tip = total * .2
    new_total = total + tip
    return new_total


def total_bill(func, value):
    total = func(value)
    return ("The total amount owed is $" + "{:.2f}".format(total) + ". Thank you! :)")

total_bill(add_tip, 100)


bills = [115, 120, 42]
new_bills = []

for i in range(len(bills)):                     #loop iterating through the indexed bills - counts from 0 to 2
    total = add_tax(bills[i])                   #total > ran through the add tax function > bills i
    print(total)
    new_bills.append("Total amount owed is Â£" + "{:.2f}".format(total) + ". Thank you! :)")

print(new_bills)




#map(function, parameter) - converts function input into a list

def double(x):                 # defining a function which doubles input by 2 
    return x * 2
int_list = [3, 6, 9]             # defining interget list to use as an input 
doubled = map(double, int_list)   # new variable = map(function we want to use, parameter we want to use i.e. the intlist) 
print(list(doubled))              # we have to use print(list(doubled)) to show the results here as otherwise it just tells us that we have a map object 

def triple(x):
    return x * 3
new = map(triple, int_list)
print(list(new))

def quadruple(x):
    return x * 4

new2 = map(quadruple, int_list)
print(list(new2))   


doubled = map(lambda input: input*2, int_list)      # new variable = map(lambda input: input*2, int_list
print(list(doubled))


#saves us typing out a function as now we can run any number as x for an equation of x5
function = lambda x: x*5                                                      #lambda is much easier than using def (as this takes up loads of lines of code. 
print(function(10))
